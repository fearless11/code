<!-- TOC -->

- [什么是并发？](#什么是并发)
    - [并发&并行](#并发并行)
    - [进程&线程&goroutine](#进程线程goroutine)
    - [进程&线程](#进程线程)
    - [线程&goroutine](#线程goroutine)
    - [进程间通信方式](#进程间通信方式)
    - [goroutine配置](#goroutine配置)
    - [goroutine的GMP模型](#goroutine的gmp模型)
    - [线程调度模型](#线程调度模型)
- [并发要解决的问题？](#并发要解决的问题)
    - [竞争状态](#竞争状态)
    - [解决竞争办法](#解决竞争办法)
    - [并发模式](#并发模式)
    - [通道](#通道)
        - [无缓冲通道](#无缓冲通道)
        - [有缓冲通道](#有缓冲通道)

<!-- /TOC -->


## 什么是并发？

### 并发&并行

- 并发: 同时管理很多事情，有些事可能做一半停止做其他；一次买两个包子

- 并行: 同时做很多事情，不同代码片在同时在不同处理器上执行；一口吃两个包子

### 进程&线程&goroutine

- 进程：操作系统分配资源的基本单位，资源有内存空间、文件和设备句柄以及线程等

- 线程：操作系统运算和调度的最小单位，调度处理程序中的代码

- goroutine：go逻辑处理器调度的基本单位，调度处理go代码
  
### 进程&线程

- 对应关系：一个线程只能属于一个进程，一个进程可以有多个线程
- 系统资源：系统资源分配给进程，处理器分配给线程
- 并发性：不同进程间可以并发，线程也可以
- 系统开销：创建、撤销进程比线程的开销大
  
### 线程&goroutine
  
- 对应关系: 一个线程绑定一个逻辑处理器，一个逻辑处理器管理多个goroutine
- 灵活性:   线程由内核管理与调度，goroutine由go调度器调度处理。不通过硬件时钟来定期触发调度
- 系统开销: goroutine的调度开销远远小于线程调度开销
- 栈空间:   OS的线程都有一个固定大小的栈内存(2MB)，goroutine在栈内存是按需增大和缩小，最大限制可到1GB

  [线程和gorutine区别](http://www.cnblogs.com/yanghuahui/p/9043631.html)

### 进程间通信方式

- 管道、信号、消息队列、共享内存、信号量、套接字

### goroutine配置
  
```go
// 修改任何语言运行时配置参数的时候，需要配合基准测试来评估程序运行结果

// 设置处理器核数
runtime.GOMAXPROCS(1)
```

### goroutine的GMP模型

- G：goroutine，M：线程， P：处理器，


### 线程调度模型
- 进程，操作系统，线程

## 并发要解决的问题？

### 竞争状态
没有同步情况下，对共享资源进行读写的状态
```bash
 # 竞争检测器标志来编译程序，后运行程序，查看具体竞争信息
 go build -race
```
### 解决竞争办法

- 原子函数（整型）

- 互斥锁（临界区）

- 通道（无竞争状态，通信共享）

### 并发模式

- runner : 控制程序生命周期，goroutine超时退出
- pool : 管理可复用的资源池，用有缓冲的通道记录资源的多少
- work : 管理goroutine数量，类似消费者-生产者模式，动态创建goroutine消费者处理任务

### 通道

不要通过共享内存来通信，而应该通过通信来共享内存

```go
// 无缓冲的整型通道
unbuffered := make(chan int)
// 有缓冲的字符串通道
buffered := make(chan string, 10)

// 向通道发送一个字符串
buffered <- "Gopher"
// 从通道接收一个字符串
value := <-buffered
```

#### 无缓冲通道

通过发送和接收需要共享的资源，在 goroutine 之间做同步，保证同时交换数据

#### 有缓冲通道 

关闭通道后只能从通道接收数据 不能向通道发送数据

 ```go
  resource := make(chan io.reader,4)
  
  // 清空通道前，先关闭否则会死锁
  close(resource)

  // 没有数据for阻塞，通道关闭才退出
  for r := range resource {    
      r.close()
  }

// 判断通道状态
task, ok := <-tasks
if !ok {
  // 说明通道清空且已关闭
	fmt.Println("shutting down")
	return
}
```